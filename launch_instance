import ConfigParser
import boto.iam
import argparse
import boto.ec2
import boto.route53
import copy
import os
import re
import subprocess
import time
from jira import JIRA
def get_arg_parse():
        parser= argparse.ArgumentParser(description=_doc_,formatter_class=argparse.RawDescriptionHelpFormatter)
        parser.add_argument('-c','--conf',required=True, help="Path to the config file")
        parser.add_argument('-n','--instance-number', type=int, default=1, help='Used to make unique instance names(>
        parser.add_argument('-N','--env-number', default=1, help="Used to make multiple environments. E.g., qa01, qa>
        parser.add_argument('-t','--jiraticket',help="Jira ticket number if you want any jira comment")
        parser.add_argument('-b','--billing',help="Billing code tag")
        parser.add_argument('-k','--keypair',help="Keypair name")
        return parser
def get_config( parsed_args ):
    config = ConfigParser.SafeConfigParser()
    config.add_section('vm')
    config.set('vm', 'vol_type', 'gp2')
    config.set('vm', 'shutdown_behavior', 'terminate')
    config.read(parsed_args.conf)
    return config
class LaunchInstance(object):

    def __init__( self, args, config ):
        self.config = config
        self.region = config.get( 'vm', 'region' )
        conn_iam = boto.iam.connect_to_region(self.region)
        try:
            # This is for local machines with user
            accountNum = conn_iam.get_user()['get_user_response']['get_user_result']['user']['arn'].split(':')[4]
        except boto.exception.BotoServerError:
            # This is for aws machines with iam policy attached
            iamrole = os.popen("curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/").read()
            accountNum = conn_iam.get_instance_profile(iamrole)['get_instance_profile_response']['get_instance_profi>
        # This is new Dev account
        if accountNum == 'ACCCOUNT_AWS':
            self.region_info = {'us-west-2':
                { 'domains': ['basecloud.io'],
                 'short_name': 'usw2',
                 'zone_ids': ['PRIVATE_ID','PUBLIC_ID']
                }
            }
        elif accountNum == 'ACCOUNT_AWS':
            self.region_info = {'us-west-2':
                { 'domains': ['usw2.basecloud.io'],
                  'short_name': 'usw2',
                  'zone_ids': ['PRIVATE_ID'],
                }
            }
        else:
            self.region_info = {'us-west-2':
                    { 'domains': ['usw2.basecloud.io', 'it.basecloud.io'],
 'short_name': 'usw2'
                    }, 'eu-west-1':
                    { 'domains': ['euw1.basecloud.io', 'it.basecloud.io'],
                     'short_name': 'euw1'
                    }, 'us-east-1':
                    { 'domains': ['use1.basecloud.io', 'it.basecloud.io'],
                     'short_name': 'use1'
                    }, 'eu-central-1':
                    { 'domains': ['euc1.basecloud.io', 'it.basecloud.io'],
                     'short_name': 'euc1'
                    }
                }
if not 'AWS_CREDENTIAL_FILE' in os.environ:
            os.environ['AWS_CREDENTIAL_FILE'] = os.environ['HOME'] + "/.aws/credentials"

        self.ec2 = boto.ec2.connect_to_region( self.region )

        self.image_id = config.get( 'vm', 'image_Id' )
        self.inst_type = config.get( 'vm', 'inst_type' )
        self.product = config.get( 'tags', 'product' )
        # Billing in argument takes precedence
        if args.billing:
            self.billing = args.billing
        else:
            self.billing = config.get( 'tags', 'billing' ).strip()
        if args.keypair:
            self.keypair = args.keypair
        else:
            self.keypair = ''
        images = self.ec2.get_all_images( image_ids=[self.image_id] )
        self.image = images[0]
        if self.image.platform == 'windows':
            self.block_map = None
        elif self.product == 'es' :
            self.block_map = None
            print ("Ignoring ephemeral volumes for es")
        elif "t2." not in self.inst_type :
            self.block_map = self.block_dev_map()
        else:
            print ("Ignoring block_dev_map")
            self.block_map = None
        name_tag = 'None'
        if self.image.tags.has_key('Name') and self.image.tags['Name'].strip():
            name_tag = self.image.tags['Name'].strip()
             print ("Image id: %s\nImage name: %s\nImage description: %s\nImage name tag: %s" % (
                self.image_id, self.image.name, self.image.description, name_tag))

        component = config.get( 'tags', 'component' ).strip()
        component_name = component.split('_')[0] + str(args.env_number).strip().zfill(2)
        product = config.get( 'tags', 'product' ).strip()
        product_name = product.replace("_", "")
        self.BillingCode = config.get( 'tags', 'BillingCode' ).strip()
        self.Environment = config.get( 'tags', 'Environment' ).strip()
        self.Region = config.get( 'tags', 'Region' ).strip()
        self.Vertical = config.get( 'tags', 'Vertical' ).strip()
        self.ProductGroup = config.get( 'tags', 'ProductGroup' ).strip()
        stack = component[:2]
        self.name = ( self.region_info[self.region]['short_name'] + "-" +
                            component_name + "-" +
                            product_name  + "-" +
                            str(args.instance_number).strip().zfill(3)
                            )
        filters = {"tag:Name" : self.name}
        reservations = self.ec2.get_all_reservations(filters=filters)
        self.hostgroup = ( self.region_info[self.region]['short_name'] + "-" +
                            component_name + "-" +
                            product_name
                            )
        self.stack = ( stack + str(args.env_number).strip().zfill(2) )
        if reservations and len(reservations) > 0:
            for reservation in reservations:
                for instance in reservation.instances:
                    if instance.state != 'terminated':
                        raise ValueError( "An instance with name %s already exists. Remove it or pick a different in>

        print ("Starting instance. This can take several minutes...")
        self.launch_instance();
        print ("Instance id", self.instance.id)
        if self.image.platform == 'windows':
            self.block_map = self.windows_block_dev_map()
        for (each_key, each_val) in self.config.items('tags'):
            if each_key not in ('hostgroup', 'billing', 'component', 'product', 'billingcode', 'environment', 'regio>
                self.instance.add_tag( each_key, each_val)

        self.instance.add_tag( 'Name', self.name)
        self.instance.add_tag( 'Billing_Code', self.billing )
        self.instance.add_tag( 'Owner', args.owner)
        self.instance.add_tag( 'Hostgroup', self.hostgroup )
          self.instance.add_tag( 'Component', component )
        self.instance.add_tag( 'Product', product )
        self.instance.add_tag( 'BillingCode', self.BillingCode )
        self.instance.add_tag( 'Environment', self.Environment )
        self.instance.add_tag( 'Region', self.Region )
        self.instance.add_tag( 'Vertical', self.Vertical )
        self.instance.add_tag( 'ProductGroup', self.ProductGroup )
        self.instance.add_tag( 'Stack', self.stack )

        self.route53_upsert()

        print ("Instance %s (%s) launched successfully" % ( self.name, self.instance.id ))
    def windows_block_dev_map( self ):
        block = self.ec2.get_instance_attribute(instance_id=self.instance.id, attribute='blockDeviceMapping')['block>
        bdm = boto.ec2.blockdevicemapping.BlockDeviceMapping()
        for key in block:
            bdm[key] = boto.ec2.blockdevicemapping.BlockDeviceType(delete_on_termination=True)
            self.ec2.modify_instance_attribute(self.instance.id, "BlockDeviceMapping", bdm)

    def block_dev_map( self ):

        sorted_devnames = sorted( self.image.block_device_mapping )
        root_dev_name = sorted_devnames[0]
        root_snapshot_id = self.image.block_device_mapping[root_dev_name].snapshot_id

        root_dev_map = boto.ec2.blockdevicemapping.BlockDeviceMapping()

        root_dev = boto.ec2.blockdevicemapping.BlockDeviceType();
        root_dev.volume_type = self.config.get( 'vm', 'vol_type' )
        root_dev.snapshot_id = root_snapshot_id
        root_dev.delete_on_termination = True

        root_dev_map[root_dev_name] = root_dev

        no_dev = boto.ec2.blockdevicemapping.BlockDeviceType()
        no_dev.no_device = True

        ephemerals = []
        for i in range(0, 4):
            ephemeral = boto.ec2.blockdevicemapping.BlockDeviceType()
            ephemeral.ephemeral_name = "ephemeral%s" % (i)
            ephemerals.append(ephemeral)

        # Build two lists, a list of regexes to match EC2 instance types, and a corresponding
        # list of ephemeral block device mappings for the instance types that match the regex
        regexes = []
        block_maps = []

        # These instance types get no ephemeral volumes
        regexes.append( re.compile('^(m4|m5)\.\S+$') )
        dev_map = copy.copy(root_dev_map)
        dev_map['/dev/sdb'] = no_dev
        dev_map['/dev/sdc'] = no_dev
        dev_map['/dev/sdd'] = no_dev
        dev_map['/dev/sde'] = no_dev
        block_maps.append( dev_map )
         # These instance types only get one ephemeral volume for free from Amazon
        regexes.append( re.compile('^((r3|r4)\.\S+)|(m3\.(medium|large))$') )
        dev_map = copy.copy(root_dev_map)
        dev_map['/dev/sdb'] = ephemerals[0]
        dev_map['/dev/sdc'] = no_dev
        dev_map['/dev/sdd'] = no_dev
        dev_map['/dev/sde'] = no_dev
        block_maps.append( dev_map )

        # These instance types get two ephemeral volumes for free from Amazon
        regexes.append( re.compile('^((c5|c4|c3)\.\S+)|(m3\.(xlarge|2xlarge))$') )
        dev_map = copy.copy(root_dev_map)
        dev_map['/dev/sdb'] = ephemerals[0]
        dev_map['/dev/sdc'] = ephemerals[1]
        dev_map['/dev/sdd'] = no_dev
        dev_map['/dev/sde'] = no_dev
        block_maps.append( dev_map )

        # These instance types get four ephemeral volumes for free from Amazon
        # Comments in the shell version read "Actually a i2.4xlarge"
        regexes.append( re.compile('^(c1\.\S+)|(i2\.\S+)$') )
        dev_map = copy.copy(root_dev_map)
        dev_map['/dev/sdb'] = ephemerals[0]
        dev_map['/dev/sdc'] = ephemerals[1]
        dev_map['/dev/sdd'] = ephemerals[2]
        dev_map['/dev/sde'] = ephemerals[3]
        block_maps.append( dev_map )

        # Match the instance type to its ephemeral block devices
        instance_type = self.config.get( 'vm', 'inst_type' ).strip()
        for i in range(0, len(regexes)):
            if regexes[i].match(instance_type):
                return block_maps[i]

        raise ValueError( "Unsupported instance type", instance_type )

    def launch_instance( self ):
        try:
            res = self.ec2.run_instances(
                                    image_id = self.image_id,
                                    key_name = self.keypair,
                                    instance_type = self.config.get( 'vm', 'inst_type' ).strip(),
                                    subnet_id = self.config.get( 'vm', 'subnet' ).strip(),
                                    block_device_map = self.block_map,
                                    instance_initiated_shutdown_behavior = self.config.get( 'vm', 'shutdown_behavior>
                                    security_group_ids = map( str.strip, self.config.get( 'vm', 'sgids' ).split( ','>
                                    instance_profile_name = self.config.get( 'vm', 'iam_profile' ).strip()
                                    )

            instance = res.instances[0]
            status = instance.update()
            for _ in range(0,60):
                if status == 'running':
                 break
                time.sleep(5)
                status = instance.update()

            if status == 'running':
                self.instance = instance
            else:
                raise RuntimeError( "Error: instance did not come up in 5 minutes" )

        except boto.exception.EC2ResponseError as detail:
            print ('EC2 error:', detail)
            raise detail
    def route53_upsert( self ):
        domains = self.region_info[self.region]['domains']
        try:
            zone_ids = self.region_info[self.region]['zone_ids']
        except:
            zone_ids = ''
        try:
            conn = boto.route53.connect_to_region( self.region )
            ip_addr = self.instance.private_ip_address
            for domain in domains:
                if zone_ids:
                    for zone_id in zone_ids:
                        fqdn = self.name + "." + domain
                        change_set = boto.route53.record.ResourceRecordSets( conn, zone_id )
                        changes1 = change_set.add_change( "UPSERT", fqdn, type="A" )
                        changes1.add_value( ip_addr )
                        change_set.commit()
                        print ("Added an A record pointing %s to %s" % (fqdn, ip_addr))
                else:
                    zone = conn.get_zone( domain )
                    fqdn = self.name + "." + domain
                    change_set = boto.route53.record.ResourceRecordSets( conn, zone.id )
                    changes1 = change_set.add_change( "UPSERT", fqdn, type="A" )
                    changes1.add_value( ip_addr )
                    change_set.commit()
                    print ("Added an A record pointing %s to %s" % (fqdn, ip_addr))

        except boto.route53.exception.DNSServerError as detail:
            print ('Route53 error:', detail)
            raise detail
        if args.jiraticket:
           comment = "Added an A record pointing %s to %s" % (self.name+".it.basecloud.io" , self.instance.private_i>
           self.write_jira_comment(args.jiraticket, comment)
    def write_jira_comment( self, jiraticket, comment ):
      jira = JIRA((os.environ['JIRAURL']),basic_auth=(os.environ['JIRAUSER'], os.environ['JIRAPASSWORD']))
      issue = jira.issue(jiraticket)
      jira.add_comment(issue, comment)
      print ("Added Ec2 Instace details in %s jiraticket" %jiraticket)
parser = get_arg_parse()
args = parser.parse_args()
config = get_config(args)
LaunchInstance( args=args, config=config )



